/**
 * Copyright 2012 Atlassian
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.atlassian.svn2git

object Tags {

  /**
   * Create annotated tags for the Subversion tags converted by git-svn.
   */
  def annotate(cmd: Cmd)(implicit options: Clean.Options) {
    import cmd._
    import git.$

    println("# Creating annotated tags...")

    git.forEachRefFull("refs/remotes/tags/")

      // ignore intermediate references generated by git-svn, like tag@42,
      // when it can not link the source of the copy to an existing remote;
      // otherwise "git-rev-parse --verify" (below) fails because it parses
      // tag@42 as an ordinal specification (i.e. tag@{42})
      .filterNot(git.isIntermediateRef(_))
      .foreach {

        tag_ref =>
          val tag = tag_ref stripPrefix "refs/remotes/tags/"
          val tree = $("git", "rev-parse", tag_ref)

          val target_ref = try {
            // Find the oldest ancestor for which the tree is the same.
            val parent_ref = findOldestAncestor(git, tree, tag_ref)

            // If this ancestor is in trunk then we can just tag it, otherwise the tag has diverged from trunk
            // and it's actually more like a branch than a tag.
            val parent = $("git", "rev-parse", parent_ref)
            if ($("git", "merge-base", "refs/remotes/trunk", parent) == parent) {
              parent
            } else {
              println("tag has diverged: " + tag)
              tag_ref
            }
          } catch {
            case ex: RuntimeException => tag_ref
          }

          // Create an annotated tag based on the last commit in the tag
          println("Creating annotated tag '%s' at %s.".format(tag, target_ref))
          if (options.shouldCreate) {
            git("git", "show", "-s", "--pretty=format:%s%n%n%b", tag_ref) #|
              git(Seq("git", "tag", "-f", "-a", "-F", "-", tag, target_ref),
                "GIT_COMMITTER_NAME" -> $("git", "show", "-s", "--pretty=format:%an", tag_ref),
                "GIT_COMMITTER_EMAIL" -> $("git", "show", "-s", "--pretty=format:%ae", tag_ref),
                "GIT_COMMITTER_DATE" -> $("git", "show", "-s", "--pretty=format:%ad", tag_ref)) !;
          }
      }
  }

  def findOldestAncestor(git: Git, tree: String, tag_ref: String) = {
    var parent_ref = tag_ref
    while (git.$("git", "rev-parse", "--quiet", "--verify", parent_ref + "^:") == tree) {
      parent_ref = parent_ref + "^"
    }
    parent_ref
  }

  // Reconcile tags between Git/Subversion.
  def checkObsolete(cmd: Cmd)(urls: Array[String])(implicit options: Clean.Options) {
    import cmd._
    println("# Checking for obsolete tags...")

    val svnTags = cmd.svn.findItems(urls)
    // Map of (tag as it appears in Subversion -> tag as it appears in Git).
    // e.g. ("my tag" -> "my%20tag")
    val gitTags = git.forEachRef("refs/tags/").map(tag => (git.decodeRef(tag), tag)).toMap

    // Remove tags deleted in Subversion.
    val excessTags = gitTags -- svnTags
    if (excessTags.nonEmpty) {
      excessTags.values.foreach { tag =>
        println("Deleting Git tag '%s' not in Subversion.".format(tag))
        if (options.shouldDelete) {
          git("git", "tag", "-d", tag) !
        }
      }
    } else {
      println("No obsolete tags to remove.")
    }

    // Should never do anything if the correct tag roots were given to git-svn.
    (svnTags diff gitTags.keys.toSeq).foreach("WARNING: Subversion tag missing in Git: " + _)
  }

  /**
   * Fix tag names after conversion.
   */
  def fixNames(cmd: Cmd)(implicit options: Clean.Options) {
    import cmd._
    import git.$
    println("# Cleaning tag names")

    // list Git tag that needs fixing
    git.forEachRef("refs/tags/")
      .filter(t => git.decodeRef(t) != t)
      .foreach { t =>
        val c = t concat "^{commit}" // commit the tag is referring to
        println("Replacing tag '%s' with '%s' at %s.".format(t, git.cleanRef(t), c))
        if (options.shouldCreate) {
          git("git", "show", "-s", "--pretty=format:%s%n%n%b", c) #|
            git(Seq("git", "tag", "-a", "-F", "-", git.cleanRef(t), c),
              "GIT_COMMITTER_NAME" -> $("git", "show", "-s", "--pretty=format:%an", c),
              "GIT_COMMITTER_EMAIL" -> $("git", "show", "-s", "--pretty=format:%ae", c),
              "GIT_COMMITTER_DATE" -> $("git", "show", "-s", "--pretty=format:%ad", c)) !
        }
        if (options.shouldDelete) git("git", "tag", "-d", t) !
      }
  }

}
